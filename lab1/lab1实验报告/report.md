# 实验报告：[Lab1]

**作者：** [刘玥彤2312747]
**作者：** [刘玥彤2312747]
**作者：** [刘玥彤2312747]

---


### 1.1 实验目的

实验1主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识。
本章你将学到：
- 使用 链接脚本 描述内存布局
- 进行 交叉编译 生成可执行文件，进而生成内核镜像
- 使用 OpenSBI 作为 bootloader 加载内核镜像，并使用 Qemu 进行模拟
- 使用 OpenSBI 提供的服务，在屏幕上格式化打印字符串用于以后调试
  
---

### 1.2 实验内容

实验1主要讲解最小可执行内核和启动流程。我们的内核主要在 Qemu 模拟器上运行，它可以模拟一台 64 位 RISC-V 计算机。为了让我们的内核能够正确对接到 Qemu 模拟器上，需要了解 Qemu 模拟器的启动流程，还需要一些程序内存布局和编译流程（特别是链接）相关知识,以及通过opensbi固件来通过服务。

---

本部分由【刘玥彤2312747】编写。
### 2.1 练习1：理解内核启动中的程序入口操作

阅读 kern/init/entry.S内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

1.**la sp, bootstacktop指令**
bootstacktop 标签在文件的 .data 段中被定义，它位于 bootstack 这块预留的栈内存空间的最高地址处。执行指令将 bootstacktop 这个标签的内存地址加载到 sp 寄存器中，这样，sp 寄存器就指向了内核初始栈的顶部。
这条指令的目的是初始化内核的第一个栈，设置一个合法的栈指针，为 C 函数调用做准备。

2.**tail kern_init指令**
它使程序的执行流直接跳转到 kern_init 标签所在的地址，并且不会在栈上保存返回地址。这意味着，kern_entry 这个函数的使命到此结束，程序将一去不复返地进入 kern_init 函数。
这条指令的目的是将控制权从汇编代码移交给 C 代码。汇编代码 kern_entry 的任务已经完成，现在需要跳转到用 C 语言编写的内核主初始化函数 kern_init() 中，并且永远不需要返回。


### 2.2 练习2: 使用GDB验证启动流程

为了熟悉使用 QEMU 和 GDB 的调试方法，请使用 GDB 跟踪 QEMU 模拟的 RISC-V 从加电开始，直到执行内核第一条指令（跳转到 0x80200000）的整个过程。通过调试，请思考并回答：RISC-V 硬件加电后最初执行的几条指令位于什么地址？它们主要完成了哪些功能？请在报告中简要记录你的调试过程、观察结果和问题的答案。

1.  **准备工作：** 
   配置RISC-V GDB环境，并启动QEMU模拟器。

2.  **核心操作：** 
   在vscode中使用“拆分终端”，在左边的终端中执行*make debug*，负责启动 QEMU 并让它等待，在右边的终端中执行*make gdb*。
   ![替代文本](images/启动.png "可选标题")
   现在我们执行几条指导书上的指令验证一下环境是否配置成功。
   执行 *b kern_entry* 指令，将调试器（GDB）定位到内核入口点并设置断点。输出表示 GDB 成功地将符号 kern_entry 解析为了内存地址 0x80200000，证明代码被正确地链接和加载到了预期的位置。
   执行 c 指令，让程序继续执行，并等待断点。
   Breakpoint 1, kern_entry () at kern/init/entry.S:7表示它命中了我们之前设置的 1 号断点，停止的位置是 kern_entry 函数，位于 entry.S 文件的第 7 行。并且显示了程序即将要执行的下一条指令的源代码。
   ![替代文本](images/entry.png "可选标题")
   执行 i r 指令，查看当前所有寄存器的值。ra , sp 的值都在 0x8001xxxx 范围内，这表明 CPU 暂停时，正在执行的代码和使用的栈都位于 OpenSBI 的内存空间内。
   ![替代文本](images/ir.png "可选标题")
   执行 info registers pc 指令，查看当前正在执行的指令.程序计数器的值是 0x1000,表明当前暂停在 QEMU 模拟的 ROM 中的复位地址处。
   执行 b *0x80200000 设置断点，这个地址是内核代码第一条指令所在的位置。
   执行 display /i $pc ，自动显示当前正在执行的指令。
   反复执行 si 指令，让程序单步执行，可以查看当前正在执行的指令。
   下图展示的过程主要是先通过一系列 addi 指令计算出下一个程序的入口地址，并存入 t0 寄存器，然后 jr t0 跳转到下一个程序入口，pc 的值变成了 0x80000000，标志着CPU 的控制权已经从 QEMU 的 ROM 成功交接给了 OpenSBI 固件。
   ![替代文本](images/info.png "可选标题")
   由于到终点的指令太多，我们直接执行 c 指令，让程序运行到断点为止。
   输出结果展示了 entry.S 中读取到的第 7 行内容。还有在内存地址 0x80200000 处，CPU 实际要执行的第一条指令是 auipc sp, 0x3。
   ![替代文本](images/c.png "可选标题")
   
   3. **回答问题：**
   
   (1)RISC-V 硬件加电后最初执行的几条指令位于什么地址？
   从开始0x1000 ，它是QEMU 预设的复位向量地址。

   (2)它们主要完成了哪些功能？
   - **0x1000** 计算一个基地址，为了实现位置无关代码。
   - **0x1004** 计算一个配置数据的地址。
   - **0x1008** 读取当前硬件线程（CPU 核心）的 ID，存入 a0 寄存器。
   - **0x100c** 从内存中加载OpenSBI的入口地址到 t0 寄存器。
   - **0x1010** 跳转到 t0 寄存器中存储的地址。


## 3. 讨论

列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解：

（1）知识点：多阶段的启动链条
- 通过 GDB 单步跟踪，我具体地观察到 CPU 并非直接执行内核。执行流从复位向量 0x1000 开始，执行几条指令后跳转到 0x80000000 (OpenSBI)，在 OpenSBI 执行了大量初始化代码后，最终才跳转到我们的内核入口 0x80200000 。
- 对应的 OS 原理：操作系统引导 ( BootLoading )。计算机启动时，由固件加载引导加载程序 (Bootloader)，再由 Bootloader 从硬盘加载操作系统内核到内存。
- 差异与理解：我深刻地理解到，操作系统内核并非运行在裸机上，而是运行在一个由引导程序精心准备好的环境中。内核的第一条指令实际上是整个启动链条的最后一步。

（2）知识点：内核栈的初始化
- 到达内核入口 kern_entry 后，我们看到的第一条有意义的指令就是设置栈指针 sp。
- 对应的 OS 原理：进程/线程上下文与函数调用栈。任何程序的执行都需要一个栈空间，用于函数调用、参数传递和局部变量存储。实验中的 la sp, bootstacktop 指令，正是为整个操作系统内核的运行创建第一个、也是最基础的执行上下文。
- 差异与理解：深刻理解了栈空间的重要性。

列出你认为OS原理中很重要，但在实验中没有对应上的知识点：
- 虚拟内存与分页机制
- 进程与调度
- 文件系统

---
